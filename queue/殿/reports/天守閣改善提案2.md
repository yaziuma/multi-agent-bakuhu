ポイントは2つ：

* (1) **表示ノイズ除去 + 会話の区別**（“見せ方”を変える）
* (2) **途切れない履歴**（“送り方”を変える：スナップショット→増分ログ）

以下、コードに手を入れる前提で「どこをどう変えるか」を設計として固めて、具体案まで落とすね。ざっこ〜♥（でも直せるから安心しろ）

---

## 1) 「`-` 連続」を除去しても上手くいかない理由（ありがち）

フロントで `-----` を消そうとして失敗する原因、だいたいこれ：

1. **`-` が“行”じゃなくて“折り返し後の一部”**になってる
   tmuxは折り返しや画面幅に応じて行が分割される。だから「行全体が `-`」になってないことがある。

2. **ANSIエスケープ（色・カーソル制御）が混ざってる**
   capture-paneの取り方によっては制御文字が残り、正規表現が当たらない。

3. **tmuxの “wrap/continue” の扱い**
   `capture-pane` のオプション次第で、見た目上1行でも内部では複数行になってたりする。

結論：**フロントで雑にreplaceするより、バックエンドで “整形済みテキスト” を作って送る**のが一番安定。

---

## 1-A) `-----` ノイズ除去：バックエンド側でやる（推奨）

### 方針

* まず **ANSI除去**
* 次に **`-` や `─` 系の“罫線っぽい行”を消す**
* さらに **同一罫線が連続する場合はまとめて消す**

### 実装イメージ（Python）

`ws/handlers.py` か `ws/tmux_bridge.py` の「captureした文字列を返す直前」に噛ませる。

```python
import re

ANSI_RE = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")

# 罫線扱いにする最低長（短い - は通常文と誤判定しやすい）
MIN_RULE_LEN = 10

RULE_RE = re.compile(rf"^\s*[-─━―]{MIN_RULE_LEN,}\s*$")

def sanitize_pane_text(s: str) -> str:
    # 1) ANSI除去
    s = ANSI_RE.sub("", s)

    # 2) 行単位で罫線除去（連続も潰す）
    out = []
    prev_was_rule = False
    for line in s.splitlines():
        is_rule = bool(RULE_RE.match(line))
        if is_rule:
            # 連続罫線は全部捨てる
            prev_was_rule = True
            continue
        prev_was_rule = False
        out.append(line.rstrip())

    # 3) 末尾空行が増えるのも見づらいので軽く整形
    # （必要ならここは好みで）
    return "\n".join(out).strip("\n")
```

### tmux側の capture オプションも効く

libtmuxの内部が `tmux capture-pane` なら、ここを見直すと“途切れ”にも効く：

* `-J`（wrap行を結合）→ 折り返しが原因の「謎の分割」減る
* `-S -2000`（スクロールバックから取る）→ 履歴対策にも効く

「どこで指定してるか」は実ファイル見ないと断言できないけど、READMEの構成だと `ws/tmux_bridge.py` にありそう。 ([GitHub][1])

---

## 1-B) 「ユーザ入力と将軍返答が見分けつかない」問題：UI構造を変えるのが正解

今は「tmuxの画面」しか出してないから、ユーザ入力も“画面内テキスト”として混ざる。これを分けるには2ルート：

### ルートA（最小改修）：送信時に“マーカー行”を挿入する

`POST /api/command` で tmux に送る直前に、**自分の入力を “ログ用の見える文字列” として別行で打ち込む**。

例：

* まず `⟦YOU⟧ <入力>` をtmuxに送る
* 次に本命の入力を送る

ただしデメリット：Claude Codeの入力欄UIによっては変になる可能性がある（チャット入力に余計な文字が入る）。なので「Claude CodeがUIで入力欄を持つタイプ」だと危険。

### ルートB（推奨）：Web側で“会話ログ”を持つ（tmux画面と別レイヤ）

* ユーザが送信した文は **Web UIが保持**（色分け・タグ付け可能）
* 将軍側は **tmux出力の増分**だけを抽出して append

これなら、tmuxの画面が多少汚くても「会話」は綺麗に読める。

#### フロント側（例）

* `#chat-log` に `<div class="msg user">…</div>` を追加
* サーバから来た増分を `<div class="msg shogun">…</div>` で追加

CSSはこう：

```css
.msg { padding: 8px 10px; border-radius: 10px; margin: 6px 0; white-space: pre-wrap; }
.msg.user { background: rgba(80,160,255,.15); border: 1px solid rgba(80,160,255,.35); }
.msg.shogun { background: rgba(255,220,80,.12); border: 1px solid rgba(255,220,80,.30); }
.msg.system { opacity: .75; font-style: italic; }
```

---

## 2) 「履歴がない／最新しか見れない／途切れる」問題：スナップショット配信の限界

README通り、現状は「pane outputを一定間隔で更新」だよね。 ([GitHub][1])
この方式の欠点：

* 画面更新の合間に流れた行が **次回スナップショットに残らない**（＝途切れ）
* Web側が “上書き表示” だと **スクロールバックが消える**
* tmuxの capture 範囲が小さいと **そもそも過去が取れない**

### 解決策の本命：WebSocketで「差分（増分）だけ」を送る

#### 仕組み（たとえ）

* 今は「将軍の巻物を毎回丸ごと写真撮って送ってる」
* これを「前回から増えた行だけ、追記として送る」に変える

#### 実装の考え方

サーバ側で

* `prev_lines: list[str]` を保持
* 新しく capture した `curr_lines` と比較して

  * **末尾一致（tail match）** を使って差分抽出
* 差分だけWSで送る（`{"type":"delta","lines":[...]}`
* フロントは受け取った行を append する

##### 差分抽出（軽量で十分）

「最長共通部分」とか要らない。ログは基本末尾に伸びるから、これでOK：

```python
def compute_delta(prev: list[str], curr: list[str]) -> list[str]:
    # 末尾側の一致を探して「新規追加部分」だけ返す
    # 戻り値は curr の末尾に追加された行
    max_check = min(len(prev), len(curr), 2000)  # 念のため上限
    # i = 一致長
    i = 0
    while i < max_check and prev[-1 - i] == curr[-1 - i]:
        i += 1
    if i == 0:
        # 一致ゼロ：画面がクリアされた/別画面に遷移した可能性
        # この場合は “フル送信 + reset” が安全
        return ["⟦SYSTEM⟧ pane reset / screen changed"] + curr
    # curr の「一致部分を除いた先頭側」が新規…ではないので注意：
    # 末尾一致 i 行 → 新規は curr[:-i] の末尾差分ではなく、
    # prev と curr の長さ差を見たほうが良い
    # 安全策：prev の長さ分だけ curr を切る
    if len(curr) >= len(prev):
        return curr[len(prev):]
    return []
```

※この“長さベース”は「途中に挿入が起きない」前提。tmuxの画面が再描画されるタイプだと崩れるので、崩れたら `reset` 扱いしてフル再送する設計にしてる。

#### さらに強くするなら：tmux scrollback から取る

capture範囲を 늘やす：

* `-S -5000` とかで「過去5000行」取る
* フロント側は最大行数を決めて古い分は削る（メモリ対策）

---

## 2-A) もっと確実にする裏技：tmux pipe-pane でログファイル化

Claude Codeみたいな “画面再描画が多いTUI” は、capture-pane差分が乱れることがある。そういう時の逃げ道：

* tmuxに `pipe-pane` を仕込んで **ペイン出力をファイルに追記**
* サーバはそのファイルを tail して配信（オフセット管理）

メリット：**途切れない・差分抽出が楽**
デメリット：セッション起動時に仕込みが必要（start.sh側や幕府起動側の責務になる）

---

## 3) お兄さんの2件を最短で直す「おすすめ実装順」

手戻り少ない順でいく。

### Step 1：バックエンド sanitize（`-----` 消す）

* ANSI除去 + 罫線除去をサーバで確実に
* ここだけで「表示狭い」はかなり改善する

### Step 2：フロントに “あなたの送信ログ” を独立表示

* tmux画面に混ぜない
* 送信した瞬間にUIに `user` ブロック追加（色分け）

### Step 3：WebSocketを“スナップショット上書き”から“delta append”へ

* 途切れと履歴を同時に解決
* フロント側は append + 上限行数でトリム

### Step 4（必要なら）：pipe-paneログ方式へ

* TUI再描画で差分が壊れるなら、この逃げ道が強い

---

## 重要まとめ

* `-----` はフロントのreplaceより、**バックエンドでANSI除去→罫線除去**が安定。
* 「見分けがつかない」は、tmux画面に頼らず **Webが会話ログを持つ設計**にすると一発で解決。
* 「履歴がない／途切れる」は、**スナップショット配信の限界**。WebSocketを **増分（delta）配信**に変えるのが本命。
