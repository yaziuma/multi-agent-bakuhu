## 改善提案まとめ（優先度つき）

### P0：監視取得を1本化してブロードキャスト（最重要）

**目的**：接続数が増えても tmux 叩き回数が増えない設計にする（負荷の根を断つ）

* **現状の危険**：WebSocket接続ごとに `capture_all_panes` / `capture_pane` すると、クライアント数×ポーリング回数で負荷が線形増
* **改善**：

  * サーバ内で **監視ループ（producer）を1本だけ**動かす
  * 各WebSocketは **購読（consumer）**して配信を受けるだけ

**実装方針**

* `MonitorBroadcaster`（または `TmuxPoller`）を作る

  * `asyncio.create_task()` で起動（アプリ起動時 or 初回接続時）
  * `subscribers: set[WebSocket]` を持ち、更新があれば全員へ送る
* 接続/切断で subscribe / unsubscribe

**期待効果**

* tmux取得回数が「接続数依存」→「固定」になる
* CPU/帯域/遅延がまとめて改善

---

### P0：tmux操作は専用スレッドプール＋直列化（イベントループ保護）

**目的**：libtmux（ブロッキング）で FastAPI のイベントループを止めない＋同時実行でtmuxを壊さない

**改善**

* `asyncio.to_thread()` 自体は使ってOK。ただし

  * **専用 `ThreadPoolExecutor(max_workers=1〜2)`** を用意（無制限に投げない）
  * tmuxアクセスは **`asyncio.Lock` で直列化**（同時 capture を避ける）

**期待効果**

* WebSocketやコマンド送信の応答性が安定
* 接続が増えてもスレッド詰まりしにくい

---

### P1：差分配信を“pane単位”に（通信量・描画負荷を削減）

**目的**：変化がない時に送らない／変化があった部分だけ送る

**改善**

* 送信形式を「全ペイン丸ごと」→「更新あったpaneだけ」へ
* 比較は巨大文字列の `!=` ではなく、**ハッシュ比較**（例：sha1）で軽くする

**送信例（案）**

```json
{
  "ts": 1700000000,
  "updates": {
    "pane_id_1": "new lines ...",
    "pane_id_3": "new lines ..."
  }
}
```

**期待効果**

* エージェント待機中の通信がほぼゼロ
* フロントの再描画が軽い（差分マージだけ）

---

### P1：ポーリング間隔は“体感”基準で可変に

**目的**：止まってる時は低頻度、動いてる時は高頻度で体感と負荷を両立

**案**

* 基本：Monitor 3s / Shogun 1s
* ただし「直近N回変化なし」なら 5s〜10s に伸ばす
* 変化検知したら即 1s〜3s に戻す

**期待効果**

* 無駄ポーリングがさらに減る
* 操作時のレスポンスは維持

---

### P2：例外握りつぶし廃止（運用性改善）

**目的**：障害時に原因が追えるようにする（ゾンビ化防止）

**改善**

* `WebSocketDisconnect` は正常終了
* それ以外はログ出して終了
* `finally` でunsubscribe等を確実に実行

**期待効果**

* “黙って壊れる”を防ぐ
* 再現性のない不具合調査が楽になる

---

### P3：dashboard.md はmtimeキャッシュ（優先度低）

**目的**：無駄I/Oを減らす（小さな最適化）

**改善**

* `last_mtime` を持ち、変わってなければ前回内容を返す

**期待効果**

* 効果は小、でも実装が簡単

---

## 実装順（おすすめロードマップ）

1. **P0：監視取得の1本化（ブロードキャスト）**
2. **P0：専用executor＋Lockでtmux直列化**
3. **P1：pane単位の差分配信＋ハッシュ比較**
4. **P1：可変ポーリング**
5. **P2：例外/ログ整備**
6. **P3：dashboard mtimeキャッシュ**
